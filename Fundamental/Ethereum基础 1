账户：
  两类账户，共用一个地址空间，外部账户，由人类的公钥-私钥对来控制，合约账户，用存储在账户中的代码控制。
  账户地址，外部账户由公钥决定，合约账户的地址是创建该合约时确定的（由合约创建着地址和该地址发出的交易数量计算得到 nonce）。
  合约账户存储代码，外部账户没有，除了这点，两类账户对于EVM来说是一样的。
  每个账户有一个key-value形式的持久化存储，其中key和value的长度都是256比特，名字叫storage
  每个账户有一个以太币余额（单位是“wei”），该账户余额可以用过向它发送带有以太币交易来改变
 
交易：
  一笔交易是一条消息，从一个账户发送到另一个账户（可能是相同的账户，或者是零账户）
  交易可以包含二进制数据（payload）和以太币
  如果目标账户包含代码，则代码会被执行，payload就是输入数据
  如果目标账户是零账户，即交易中的to是空，则交易创建一个新的合约。创建合约的payload被当做EVM字节码执行，执行的输出作为合约代码（由编写的代码转成EVM可认识
  的字节码）被永久存储，因为创建合约，就是发送一段可以创建合约代码的代码给EVM,最后EVM创建出合约代码，被永久存储
 
Gas:
  每笔交易都会被收取一定数量的gas, EVM执行交易时，gas按照特定规则逐渐消耗
  gas price（以太币计）是由交易创建者设置的，发送账户需要预付的交易费用 = gas price * gas amount, 如果执行结束还有gas剩余，这些gas将被返还给发送账户
  无论执行到什么位置，只要gas被耗尽，将会触发out-of-gas异常，当前调用帧所做的所有状态修改都将被回滚
  
存储 主存和栈：
  存储：（storage）每个账户都有一个持久化的内存区域。以形式key-value存在，存储的读操作相对来说开销很大，修改存储更甚。
        一个合约只能对自己的存储进行读写
  
  主存：（memory）合约执行每次消息调用时，都有一块新的，被清除过的内存。
        以字节粒度寻址，32字节，操作memory的开销随着其增长而变大（平方级别）
  
  栈：  （stack）EVM不是基于寄存器的，而是基于栈的虚拟机，因此所有的计算都是在栈中进行的。
         栈最大1024元素，每个元素32字节，对栈的访问只限于栈顶。
         允许：拷贝最顶端的16个元素中的一个到栈顶
              或者交换栈顶元素和下面16个元素中的1个
         所有其他操作都只能取栈顶的两个（或1个，或更多，取决于具体的操作）元素，并把结果压在栈顶。
         可以把栈上元素放到storage或者memory中，但是无法访问栈上指定深度的那个元素，在那之前必须把指定深度之上的元素从栈中移除
  
消息调用：
  合约可以通过消息调用的方式来调用其他合约或者发送以太币到非合约账户。
  一个合约可以决定剩余gas的分配
  被调用的合约（发起调用的合约也一样）会拥有崭新的主存并能够访问调用的负载，调用的负载被存储在一个单独的被称为calldata的区域，调用执行结束后，返回的数据
  将被存放在调用方预先分配好的一块内存中
  调用层数限制为1024，因此对于更加复杂的操作，应该用循环，而不是递归
 
代码调用和库
  特殊的消息调用，callcode，跟消息调用一样，只是加载自目标地址的代码将在发起调用的合约上下文中运行
  即合约可以在运行时从另外一个地址动态加载代码。
  存储，当前地址和余额都指向发起调用的合约
  
日志
  日志是区块层面的特性，用一种特殊的可索引的数据结构来存储数据
  solidity用它来实现事件。
  合约创建之后，无法访问日志数据，但是可以利用事件从区块链外高效访问
  部分日志被存储在Bloom filter中，可以高效安全的搜索日志
  
创建
  合约可以通过特殊的指令来创建其他合约（不是简单的向零地址发起调用）
  合约创建合约 跟 普通消息调用区别在于：负载数据执行的结果被当做代码，调用者/创建者在栈上得到新合约的地址
  
自毁
   只有在某个地址上的合约执行自毁时，合约代码才会从区块链上移除，合约地址剩余的以太币会发送给指定的目标，然后其存储和代码被移除
   注意：即使一个合约的代码不包含自毁指令，依然可以通过代码调用callcode来执行这个操作
