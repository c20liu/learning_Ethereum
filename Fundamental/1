账户：
  两类账户，共用一个地址空间，外部账户，由人类的公钥-私钥对来控制，合约账户，用存储在账户中的代码控制。
  账户地址，外部账户由公钥决定，合约账户的地址是创建该合约时确定的（由合约创建着地址和该地址发出的交易数量计算得到 nonce）。
  合约账户存储代码，外部账户没有，除了这点，两类账户对于EVM来说是一样的。
  每个账户有一个key-value形式的持久化存储，其中key和value的长度都是256比特，名字叫storage
  每个账户有一个以太币余额（单位是“wei”），该账户余额可以用过向它发送带有以太币交易来改变
 
交易：
  一笔交易是一条消息，从一个账户发送到另一个账户（可能是相同的账户，或者是零账户）
  交易可以包含二进制数据（payload）和以太币
  如果目标账户包含代码，则代码会被执行，payload就是输入数据
  如果目标账户是零账户，即交易中的to是空，则交易创建一个新的合约。创建合约的payload被当做EVM字节码执行，执行的输出作为合约代码（由编写的代码转成EVM可认识
  的字节码）被永久存储，因为创建合约，就是发送一段可以创建合约代码的代码给EVM,最后EVM创建出合约代码，被永久存储
 
Gas:
  每笔交易都会被收取一定数量的gas, EVM执行交易时，gas按照特定规则逐渐消耗
  gas price（以太币计）是由交易创建者设置的，发送账户需要预付的交易费用 = gas price * gas amount, 如果执行结束还有gas剩余，这些gas将被返还给发送账户
  无论执行到什么位置，只要gas被耗尽，将会触发out-of-gas异常，当前调用帧所做的所有状态修改都将被回滚
  
存储 主存和栈：
  存储：（storage）每个账户都有一个持久化的内存区域。以形式key-value存在，存储的读操作相对来说开销很大，修改存储更甚。
        一个合约只能对自己的存储进行读写
  
  主存：（memory）合约执行每次消息调用时，都有一块新的，被清除过的内存。
        以字节粒度寻址，32字节，操作memory的开销随着其增长而变大（平方级别）
  
  栈：  （stack）EVM不是基于寄存器的，而是基于栈的虚拟机，因此所有的计算都是在栈中进行的。
         栈最大1024元素，每个元素32字节，对栈的访问只限于栈顶。
         允许：拷贝最顶端的16个元素中的一个到栈顶
              或者交换栈顶元素和下面16个元素中的1个
         所有其他操作都只能取栈顶的两个（或1个，或更多，取决于具体的操作）元素，并把结果压在栈顶。
         可以把栈上元素放到storage或者memory中，但是无法访问栈上指定深度的那个元素，在那之前必须把指定深度之上的元素从栈中移除
  
